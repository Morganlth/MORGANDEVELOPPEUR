<!-- #MAP

-COMMAND
-EVENT
    SNAKE
        CANVAS

        #if
            GRID
            PARTICLES
            #if GAMEOVER
            FRAME
                SCRORE
                FPS
                CELL
                    ICON
                        CROSS

-->

<!-- #SCRIPT -->

<script>
// #EXPORT

    // --BIND
    export let snake_GAME = false

// #IMPORTS

    // --JS
    import fps_get from '../../assets/js/utils/fps'
    import { color_rgba } from '../../assets/js/utils/color'

    // --LIB
    import COLORS from '$lib/colors'

    // --CONTEXTS
    import { COMMAND, EVENT } from '../../App.svelte'

    // --SVELTE
    import { onMount, onDestroy } from 'svelte'

    // --COMPONENT-COVERS
    import Cell from '../covers/Cell.svelte'
    import Icon from '../covers/Icon.svelte'

    // --COMPONENT-ICON
    import Cross from '../icons/Cross.svelte'

    // --COMPONENT-DECOR
    import Particles from '../decors/Particles.svelte'

// #CONSTANTES

    // --ELEMENT-SNAKE
    const
    SNAKE_BLOCKSIZE = 40,
    SNAKE_SNAKE = [],
    SNAKE_APPLE = [],
    SNAKE_COMMANDS =
    [
        {
            name: 'snake_size',
            callback: snake_c$Size,
            params: { defaultValue: SNAKE_BLOCKSIZE, min: 10, max: 70 },
            tests: { testBoolean: true, testNumber: true },
            storage: true
        }
    ],
    SNAKE_EVENTS =
    {
        scroll: snake_e$Scroll,
        mouseMove: snake_e$MouseMove,
        resize: snake_e$Resize
    }

// #VARIABLES

    // --EVENT
    let
    event_CLIENT_X = 0,
    event_CLIENT_Y = 0

    // --ELEMENT-SNAKE
    let
    snake,
    snake_WIDTH = 0,
    snake_HEIGHT = 0,
    snake_OFFSET_TOP = 0,
    snake_OFFSET_LEFT = 0,
    snake_COLOR_BODY = color_rgba(COLORS.primary, .6),
    snake_X = -1,
    snake_Y = -1,
    snake_BLOCKSIZE,
    snake_INVINCIBLE = true,
    snake_SCORE = 10,
    snake_FPS = 0,
    snake_TIMEOUT

    // --ELEMENT-CANVAS
    let
    canvas,
    canvas_CONTEXT,
    canvas_COLUMNS,
    canvas_ROWS,
    canvas_CLIENTRECT

    // --ELEMENT-GAMEOVER
    let gameover_ON = false

// #REACTIVE

    // --ELEMENT-SNAKE
    $: snake_GAME ? snake_start() : void 0

// #FUNCTIONS

    // --SET
    function snake_set()
    {
        snake_setVars()
        snake_setCommands()
        snake_setEvents()

        snake_setSnake()
        snake_setApple()
    }

    function snake_setVars()
    {
        const [WIDTH, HEIGHT] = [snake.offsetWidth, snake.offsetHeight]

        snake_BLOCKSIZE = WIDTH < 768 || HEIGHT < 768 ? 30 : SNAKE_BLOCKSIZE

        snake_WIDTH = WIDTH - (WIDTH - 1) % snake_BLOCKSIZE
        snake_HEIGHT = HEIGHT - (HEIGHT - 1) % snake_BLOCKSIZE

        snake_OFFSET_TOP = (HEIGHT - snake_HEIGHT) / 2
        snake_OFFSET_LEFT = (WIDTH - snake_WIDTH) / 2

        canvas_setVars()
    }

    function snake_setCommands() { COMMAND.command_setBasicCommands(SNAKE_COMMANDS) }

    function snake_setEvents() { EVENT.event_add(SNAKE_EVENTS) }

    function snake_setSnake()
    {
        const CENTER_X = Math.floor(canvas_COLUMNS / 2)
    
        for (let i = 0; i < snake_SCORE; i++) SNAKE_SNAKE.push([CENTER_X, -1 - i])
    }

    function snake_setApple()
    {
        let [x, y] = snake_getRandomXY()

        while (SNAKE_SNAKE.some(body => body[0] === x && body[1] === y)) [x, y] = snake_getRandomXY()

        SNAKE_APPLE[0] = x
        SNAKE_APPLE[1] = y
    }

    function snake_setScore() { snake_SCORE = SNAKE_SNAKE.length }

    function canvas_setVars()
    {
        canvas.width = snake_WIDTH
        canvas.height = snake_HEIGHT

        canvas_COLUMNS = snake_WIDTH / snake_BLOCKSIZE
        canvas_ROWS = snake_HEIGHT / snake_BLOCKSIZE

        canvas_CONTEXT = canvas_CONTEXT ?? canvas.getContext('2d')

        canvas_setClientRect()
    }
    function canvas_setClientRect() { canvas_CLIENTRECT = canvas.getBoundingClientRect() }

    // --DESTROY
    function snake_destroy() { snake_destroyEvents() }

    function snake_destroyEvents() { EVENT.event_remove(SNAKE_EVENTS) }

    // --GET
    function snake_getRandomXY() { return [Math.floor(Math.random() * (canvas_COLUMNS - 2) + 1), Math.floor(Math.random() * (canvas_ROWS - 2) + 1)] }

    function snake_getModel(pre, current, next)
    {
        const [X, Y] = [Math.abs(current[0]), Math.abs(current[1])]
        
        return [pre ? snake_getPosition(pre, X, Y) : null, snake_getPosition(next, X, Y)]
    }

    function snake_getPosition(body, x, y) { return [['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i']][1 + (Math.abs(body[1]) - y)][1 + (Math.abs(body[0]) - x)] }

    function snake_getDimensions(model)
    {
        let [offset_X, offset_Y] = [1, 1]

        for (const M of model)
            switch (M)
            {
                case 'a':
                    offset_X = 0
                    offset_Y = 0
                    break
                case 'b':
                case 'c':
                    offset_Y = 0
                    break
                case 'd':
                case 'g':
                    offset_X = 0
                    break
                default:
                    break
            }

        return [offset_X, offset_Y]
    }

    // --UPDATE
    function snake_update()
    {
        snake_setApple()

        if (!snake_INVINCIBLE)
        {
            SNAKE_SNAKE.push([])
            
            snake_setScore()
        }
    }

    function snake_updateCoords()
    {
        snake_X = Math.floor((event_CLIENT_X - snake_OFFSET_LEFT) / snake_BLOCKSIZE)
        snake_Y = Math.floor((event_CLIENT_Y - snake_OFFSET_TOP) / snake_BLOCKSIZE)
    }

    function gameover_update(on)
    {
        gameover_ON = on

        if (on)
        {
            snake_INVINCIBLE = true

            snake_a('clearRect')
        }
        else
        {
            snake_moveTo()

            SNAKE_SNAKE.length = 10
    
            snake_setScore()
            snake_a('fillRect')
            snake_notInvincible()
        }
    }

    // --COMMAND
    function snake_c$Size(size)
    {
        snake_BLOCKSIZE = size

        snake_e$Resize()
    }

    // --EVENTS
    async function snake_e$Scroll() { snake_move() }

    async function snake_e$MouseMove(clientX, clientY)
    {
        [event_CLIENT_X, event_CLIENT_Y] = [clientX, clientY]

        snake_move()
    }

    async function snake_e$Resize()
    {
        snake_setVars()
        snake_setApple()

        snake_draw()
    }

    function snake_eFullscreenChange() { if (!document.fullscreenElement) snake_end() }

    function canvas_eMouseLeave(e)
    {
        const TARGET = e.relatedTarget

        if (!TARGET || TARGET.classList.contains('snake')) gameover_update(true)
    }

    function cell_eClick()
    {
        document.exitFullscreen()
    
        snake_end()
    }

    function gameover_eClick() { gameover_update(false) }

    // --ANIMATION
    function snake_a(tool, min = 0) // dessine ou supprime de façon animé (serpent et pomme)
    {
        let delay = 0
    
        canvas_CONTEXT.fillStyle = snake_COLOR_BODY

        for (let i = SNAKE_SNAKE.length - 1; i >= min; i--)
        {
            const BODY = SNAKE_SNAKE[i]

            setTimeout(() =>
            {
                if (i === 0) canvas_CONTEXT.fillStyle = COLORS.primary

                canvas_CONTEXT[tool](BODY[0] * snake_BLOCKSIZE, BODY[1] * snake_BLOCKSIZE, snake_BLOCKSIZE, snake_BLOCKSIZE)
            }, delay += 16.67)
        }
    }

    // --LOOP
    async function snake_loop()
    {
        snake_FPS = await fps_get()

        if (snake_GAME) snake_loop()
    }

    // --CONTROLS
    function snake_start()
    {
        try
        {
            snake.requestFullscreen().then(snake_notInvincible)

            snake_loop()
        }
        catch (e) { snake_end() }
    }

    function snake_end()
    {      
        snake_GAME = false
        snake_INVINCIBLE = true

        gameover_ON = false

        snake_moveTo()
        snake_a('fillRect')
    }

    // --TESTS
    function snake_testMove() { return SNAKE_SNAKE[0][0] !== snake_X || SNAKE_SNAKE[0][1] !== snake_Y }

    function snake_testEatenApple(x, y) { if (x === SNAKE_APPLE[0] && y === SNAKE_APPLE[1]) snake_update() }

    function snake_testOverlay([x, y]) { if (!snake_INVINCIBLE && x === snake_X && y === snake_Y) gameover_update(true) }

    // --DRAW
    function snake_draw()
    {
        const [X, Y] = SNAKE_SNAKE[0]

        let
        [gap_X, gap_Y] = [X - snake_X, Y - snake_Y],
        [add_X, add_Y] = [snake_X < X ? -1 : 1, snake_Y < Y ? -1 : 1],
        i = 0

        while(i++ < 3)
        {
            if (gap_X !== 0) gap_X += add_X
            if (gap_Y !== 0) gap_Y += add_Y

            snake_clear()
            snake_drawApple()
            snake_drawSnake(snake_X + gap_X, snake_Y + gap_Y)

            if (gap_X === 0 && gap_Y === 0) break
        }
    }

    function snake_drawApple()
    {
        const [X, Y, SIZE] = [SNAKE_APPLE[0] * snake_BLOCKSIZE + 1, SNAKE_APPLE[1] * snake_BLOCKSIZE + 1, snake_BLOCKSIZE - 2]
    
        canvas_CONTEXT.fillStyle = COLORS.indicator
        canvas_CONTEXT.fillRect(X, Y, SIZE, SIZE)
    }

    function snake_drawSnake(x, y)
    {
        canvas_CONTEXT.fillStyle = snake_COLOR_BODY

        for (let i = snake_SCORE - 1; i > 0; i--)
        {
            const BODY = SNAKE_SNAKE[i-1]

            SNAKE_SNAKE[i] = BODY

            snake_testOverlay(BODY)
            snake_drawBody(BODY, i, x, y)
        }

        snake_drawHead(x, y)
    }
    function snake_drawBody(body, i, x, y)
    {
        const
        MODEL = snake_getModel(SNAKE_SNAKE[i + 1], body, SNAKE_SNAKE[i - 2] ?? [x, y]),
        [OFFSET_X, OFFSET_Y] = snake_getDimensions(MODEL),
        [X, Y] = [body[0] * snake_BLOCKSIZE + OFFSET_X, body[1] * snake_BLOCKSIZE + OFFSET_Y]

        canvas_CONTEXT.fillRect(X, Y, snake_BLOCKSIZE - OFFSET_X, snake_BLOCKSIZE - OFFSET_Y)
    }
    function snake_drawHead(x, y)
    {
        snake_testEatenApple(x, y)

        SNAKE_SNAKE[0] = [x, y]
    
        canvas_CONTEXT.fillStyle = COLORS.primary
        canvas_CONTEXT.fillRect(x * snake_BLOCKSIZE, y * snake_BLOCKSIZE, snake_BLOCKSIZE, snake_BLOCKSIZE)
    }

    // --CLEAR
    function snake_clear() { canvas_CONTEXT.clearRect(0, 0, snake_WIDTH, snake_HEIGHT) }

    // --UTILS
    function snake_move()
    {
        snake_updateCoords()

        if (!gameover_ON && snake_testMove()) snake_draw()
    }

    function snake_moveTo()
    {
        if (!SNAKE_SNAKE.length) return

        const
        [GAPX, GAPY] = [snake_X - SNAKE_SNAKE[0][0], snake_Y - SNAKE_SNAKE[0][1]],
        MIN = Math.min(SNAKE_SNAKE.length, 10)

        for (let i = 0; i < MIN; i++)
        {
            const BODY = SNAKE_SNAKE[i]

            BODY[0] += GAPX
            BODY[1] += GAPY
        }
    }

    function snake_notInvincible()
    {
        clearTimeout(snake_TIMEOUT)

        snake_TIMEOUT = setTimeout(() => snake_INVINCIBLE = false, 1000)
    }

// #CYCLES

onMount(snake_set)
onDestroy(snake_destroy)
</script>

<!-- #HTML -->

<div
class="snake"
class:on={snake_GAME}
bind:this={snake}
on:fullscreenchange={snake_eFullscreenChange}
>
    <canvas
    style:width="{snake_WIDTH}px"
    style:height="{snake_HEIGHT}px"
    bind:this={canvas}
    on:mouseleave={canvas_eMouseLeave}
    >
    </canvas>

    {#if snake_GAME}
        <div
        class="grid"
        style:--grid-size="{snake_BLOCKSIZE}px"
        style:width="{snake_WIDTH}px"
        style:height="{snake_HEIGHT}px"
        >
        </div>

        <Particles
        prop_TEMP={true}
        />

        {#if gameover_ON}
            <button
            class="gameover"
            type="button"
            on:click={gameover_eClick}
            >
                <pre>     -GAME</pre>
                <pre>OVER---   </pre>

                <span>CLICK pour REJOUER</span>
            </button>
        {/if}

        <div
        class="frame"
        >
            <ul>
                <li
                class="score"
                >
                    SCORE
                    <span>{snake_SCORE}</span>
                </li>
                <li
                class="fps"
                >
                    FPS
                    <span>{snake_FPS}</span>
                </li>
            </ul>
            
            <Cell
            on:click={cell_eClick}
            >
                <Icon
                prop_COLOR={COLORS.light}
                prop_SPRING={false}
                >
                    <Cross />
                </Icon>
            </Cell>
        </div>
    {/if}
</div>

<!-- #STYLE -->

<style
lang="scss"
>
/* #USES */

@use 'sass:map';

@use '../../assets/scss/app';

@use '../../assets/scss/styles/elements';
@use '../../assets/scss/styles/position';
@use '../../assets/scss/styles/display';
@use '../../assets/scss/styles/size';
@use '../../assets/scss/styles/font';

/* #SNAKE */

.snake
{
    &, .gameover
    {
        @include position.placement(absolute, 0, 0, 0, 0);
    
        @extend %any;
    }

    @extend %f-center;

    pointer-events: none;

    &.on
    {
        background-color: $dark;

        canvas
        {
            pointer-events: auto;

            border: solid $intermediate .8rem;
        }
    }

    .grid
    {
        position: absolute;

        background:
        repeating-linear-gradient($intermediate 0 1px, transparent 1px 100%),
        repeating-linear-gradient(90deg, $intermediate 0 1px, transparent 1px 100%);

        background-size: var(--grid-size) var(--grid-size);
    }

    .gameover
    {
        @extend %button-reset;
        @extend %f-center;

        flex-direction: column;
    
        pointer-events: auto;

        pre
        {
            @include font.h-(1);
            
            @extend %m-h-1;

            font-style: italic;
        }
        span { @include font.interact($primary, map.get(font.$font-sizes, s3), 1.4); }
    }

    .frame
    {
        $font-size: map.get(font.$font-sizes, s2);

        #{--icon-size}: $font-size;

        @include position.placement(absolute, calc(app.$gap-block * 2), app.$gap-inline, auto, app.$gap-inline);
    
        display: flex;
        justify-content: space-between;

        height: fit-content;

        ul
        {
            display: flex;

            gap: app.$gap-inline;

            .score, .fps
            {
                @include font.interact($light, $font-size, 1, map.get(font.$content-font-weight, w1));

                span { font-weight: map.get(font.$content-font-weight, w2); }
            }
        }
    }
}
</style>